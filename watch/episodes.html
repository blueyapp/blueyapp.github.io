<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Watch Bluey!</title>

    <!-- Meta / OpenGraph -->
    <meta name="title" content="Watch Bluey!" />
    <meta name="description" content="Bluey is an inexhaustible six year-old Blue Heeler dog, who loves to play and turns everyday family life into extraordinary adventures, developing her imagination as well as her mental, physical and emotional resilience." />
    <meta name="keywords" content="bluey, children's show, family entertainment" />
    <meta name="robots" content="index, follow" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="language" content="English" />
    <meta name="author" content="Bluey Heeler" />
    <meta property="og:title" content="Watch Bluey!" />
    <meta property="og:description" content="Bluey is an inexhaustible six year-old Blue Heeler dog, who loves to play and turns everyday family life into extraordinary adventures, developing her imagination as well as her mental, physical and emotional resilience." />
    <meta property="og:image" content="https://cdn.iview.abc.net.au/thumbs/1200/ch/CH2003Q_66399c133e743_1920.jpg" />
    <meta property="og:url" content="https://pages.blueynet.org/watch/episodes" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Watch Bluey!" />
    <meta name="twitter:description" content="Bluey is an inexhaustible six year-old Blue Heeler dog, who loves to play and turns everyday family life into extraordinary adventures, developing her imagination as well as her mental, physical and emotional resilience." />
    <meta name="twitter:image" content="https://cdn.iview.abc.net.au/thumbs/1200/ch/CH2003Q_66399c133e743_1920.jpg" />
    <link rel="icon" href="/bluey-star.ico" type="image/x-icon" />

    <!-- Fonts -->
    <link href="/fonts/HelloHeadline.css" rel="stylesheet" type="text/css" />

    <!-- Video.js core -->
    <link href="https://vjs.zencdn.net/8.16.0/video-js.css" rel="stylesheet" />
    <script src="https://vjs.zencdn.net/8.16.0/video.min.js"></script>

    <!-- Chromecast plugin for Video.js + Cast Sender SDK -->
    <link rel="stylesheet" href="https://unpkg.com/@silvermine/videojs-chromecast/dist/silvermine-videojs-chromecast.css" />
    <script>
      /* Optional global config hook the plugin supports */
      window.SILVERMINE_VIDEOJS_CHROMECAST_CONFIG = { preloadWebComponents: false };
    </script>
    <script src="https://unpkg.com/@silvermine/videojs-chromecast/dist/silvermine-videojs-chromecast.min.js"></script>
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>

    <style>
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body { font-family: "Hello Headline", Arial, sans-serif !important; background-color: #87c0e8 !important; transition: background 0.3s, color 0.3s; }
      .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
      .header { display: flex; align-items: center; justify-content: space-between; }
      .logo { width: 150px; border-radius: 0px; }
      .nav { display: flex; list-style: none; }
      .nav li { margin-left: 20px; display: flex; align-items: center; }
      .nav a { text-decoration: none; color: #ffffff; font-weight: bold; }
      .main { display: flex; gap: 45px; margin-top: 30px; }
      .main-left, .main-right { flex: 1; }

      .player-wrapper { display: none; width: 100%; margin: 0 auto; box-shadow: 0 0 30px rgba(0, 0, 0, 0.7); }
      #player { width: 100%; height: auto; background-color: #000; }

      .video-js { width: 100%; height: 100%; border-radius: 6px; background: #000; position: relative; }

      #content { margin-top: 10px; position: relative; }
      #seasons-container { display: flex; margin: 0 auto; justify-content: space-between; padding: 10px 0; background-color: #87c0e8; text-align: center; max-width: 700px; flex-wrap: wrap; }
      .season-selector__button { margin: 5px; cursor: pointer; color: #ffffff; border: none; background-color: transparent; padding: 10px 10px; border-radius: 5px; font-family: 'Hello Headline', sans-serif; }
      .season-selector__button.selected { color: #000000; background-color: #ffffff; }
      #info-button { margin: 5px; cursor: pointer; color: #ffffff; background-color: #edcc6f; padding: 10px 10px; border: none; border-radius: 5px; font-family: 'Hello Headline', sans-serif; }
      #shuffle-button { margin: 5px; cursor: pointer; background: none; border: none; padding: 0; }
      #shuffle-icon { color: #fff; background: transparent; border-radius: 8px; transition: color 0.2s, background 0.2s, box-shadow 0.2s; }
      body.dark #shuffle-icon { color: #fbbf24; background: #191d25; }
      #shuffle-icon.active { color: #23293a !important; background: #ffe066 !important; box-shadow: 0 0 8px 2px #ffe066; }
      body.dark #shuffle-icon.active { color: #23293a !important; background: #ffe066 !important; box-shadow: 0 0 8px 2px #ffe066; }

      #episodes { overflow-y: scroll; scrollbar-width: thin; scrollbar-color: transparent transparent; max-height: 500px; max-width: 700px; padding: 5px 0; background-color: #87c0e8; margin: 0 auto; }
      #episodes::-webkit-scrollbar { width: 6px; }
      #episodes::-webkit-scrollbar-thumb { background-color: transparent; }
      #episodes li { margin: 5px; list-style-type: none; cursor: pointer; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px; color: #fff; background-color: #404066; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); display: flex; align-items: flex-start; }
      #episodes img { margin-right: 15px; display: block; width: 100px; height: auto; max-width: 100%; max-height: 90px; object-fit: cover; }
      #episodes li div { flex: 1; text-align: left; }
      #episodes h2 { font-size: 20px; font-weight: bold; margin: 0; }
      #episodes p { font-size: 12px; margin: 0; }
      #episodes li.selected { background-color: #ffffff; color: #000000; }

      .overlay { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1; overflow: hidden; border-radius: 10px; }
      .overlay-content { text-align: left; color: #fff; padding: 20px; display: flex; align-items: center; }
      .overlay img { max-width: 50%; margin-right: 15px; height: auto; max-height: 200px; border-radius: 5px; }
      .close-overlay { position: absolute; top: 10px; right: 10px; cursor: pointer; color: #fff; font-size: 20px; }
      .overlay-content-text { flex: 1; }
      #overlay-title { margin-bottom: 10px; }
      #download-button { margin-top: 10px; cursor: pointer; color: #ffffff; background-color: #e2793b; padding: 10px 20px; border: none; border-radius: 5px; font-family: 'Hello Headline', sans-serif; }

      #language-select { margin: 5px; cursor: pointer; color: #ffffff; background-color: #404066; padding: 10px; border: none; border-radius: 5px; font-family: 'Hello Headline', sans-serif; appearance: none; -webkit-appearance: none; -moz-appearance: none; }
      #language-select option { color: #000000; background-color: #ffffff; }

      @media (orientation: portrait) {
        .header { flex-direction: column; }
        .nav { margin-top: 20px; }
        .main { flex-direction: column; gap: 20px; }
        .main-left, .main-right { width: 100%; }
        .overlay-content { text-align: center; color: #fff; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .overlay-content-text { flex: 1; padding: 20px; }
        #download-button { margin-top: 10px; cursor: pointer; color: #ffffff; background-color: #e2793b; padding: 10px 20px; border: none; border-radius: 5px; font-family: 'Hello Headline', sans-serif; }
        #seasons-container { flex-direction: column; align-items: center; }
      }
      @media (orientation: landscape) {
        .player-wrapper { margin-top: 25px; }
        .overlay { display: none !important; }
        #info-button { display: none; }
      }

      /* Dark mode styles */
      body.dark { background: #191d25 !important; color: #dbeafe !important; }
      body.dark .header { background: #191d25 !important; }
      body.dark .nav a { color: #fbbf24 !important; }
      body.dark .main { background: none !important; }
      body.dark #seasons-container { background: #191d25 !important; }
      body.dark .season-selector__button { color: #fbbf24; background: #191d25; }
      body.dark .season-selector__button.selected { color: #23293a; background: #fbbf24; }
      body.dark #episodes { background: #191d25 !important; }
      body.dark #episodes li { background: #32436a !important; color: #fbbf24 !important; border-color: #394867; }
      body.dark #episodes li.selected { background: #fbbf24 !important; color: #23293a !important; }
      body.dark .overlay { background: rgba(0,0,0,0.92); }
      body.dark .overlay-content { color: #fbbf24; }
      body.dark #download-button, body.dark #download-button-landscape { background: #394867 !important; color: #ffd700 !important; }
      body.dark #language-select { background: #394867; color: #fbbf24; }

      /* Dark mode toggle */
      .darkmode-toggle { background: none; border: none; cursor: pointer; border-radius: 50%; margin-left: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; outline: none; padding: 2px; transition: background 0.2s; }
      .darkmode-toggle:focus, .darkmode-toggle:hover { background: rgba(128, 128, 128, 0.12); }
      .darkmode-toggle svg { width: 24px; height: 24px; display: block; pointer-events: none; }
      .dark .darkmode-toggle .sun { display: none; }
      .dark .darkmode-toggle .moon { display: block; }
      .darkmode-toggle .moon { display: none; }
      .darkmode-toggle .sun { display: block; }

      /* Episode title overlay (on local player UI – shown when controls are visible) */
      .vjs-episode-title {
        position: absolute; left: 12px; top: 12px; z-index: 3;
        padding: 6px 10px; border-radius: 6px;
        background: rgba(0,0,0,0.55); color: #fff;
        font-family: 'Hello Headline', sans-serif; font-size: 14px;
        pointer-events: none; text-shadow: 0 1px 2px rgba(0,0,0,0.4);
        opacity: 0; transition: opacity .2s ease;
      }
      .vjs-user-inactive .vjs-episode-title { opacity: 0; }
      .vjs-user-active .vjs-episode-title { opacity: 1; }
      body.dark .vjs-episode-title { background: rgba(25,29,37,0.6); color: #fbbf24; }

      /* Toast (for language fallback + notices) */
      .toast {
        position: fixed;
        left: 50%;
        bottom: 20px;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.88);
        color: #fff;
        padding: 10px 14px;
        border-radius: 8px;
        font-family: 'Hello Headline', sans-serif;
        font-size: 14px;
        opacity: 0;
        pointer-events: none;
        transition: opacity .25s, transform .25s;
        z-index: 9999;
      }
      .toast.show { opacity: 1; transform: translateX(-50%) translateY(-6px); }
      body.dark .toast { background: rgba(25,29,37,0.95); color: #fbbf24; }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header">
        <img src="/images/uFYNVaPt6dz1PH6tZ4vfdyOnKS.png" alt="Bluey" class="logo" />
        <ul class="nav">
          <li><a href="/">Home</a></li>
          <li><a href="/watch">Watch</a></li>
          <li><a href="/music">Music</a></li>
          <li><a href="/audiobooks">Audio Books</a></li>
          <li><a href="/download">App</a></li>
          <li>
            <button class="darkmode-toggle" id="darkToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
              <svg class="sun" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"/>
                <g>
                  <line x1="12" y1="1" x2="12" y2="3"/>
                  <line x1="12" y1="21" x2="12" y2="23"/>
                  <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                  <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                  <line x1="1" y1="12" x2="3" y2="12"/>
                  <line x1="21" y1="12" x2="23" y2="12"/>
                  <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                  <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                </g>
              </svg>
              <svg class="moon" viewBox="0 0 24 24" fill="none" stroke="#fbbf24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
              </svg>
            </button>
          </li>
        </ul>
      </div>

      <!-- Main Content -->
      <div class="main">
        <!-- Left: Player & Landscape Description -->
        <div class="main-left">
          <div class="player-wrapper">
            <div id="player">
              <!-- NOTE: default unmuted + autoplay (browsers may block until user gesture) -->
              <video id="bluey" class="video-js vjs-default-skin vjs-fluid" controls preload="auto" playsinline autoplay></video>
            </div>
          </div>
          <div id="landscape-description" style="display: none; margin-top: 10px; background-color: rgba(0,0,0,0.8); color: #fff; padding: 10px; border-radius: 10px;"></div>
        </div>

        <!-- Right: Seasons, Episodes & Overlay -->
        <div class="main-right">
          <div id="content">
            <div id="seasons-container">
              <div id="seasons"></div>
              <button id="shuffle-button" onclick="toggleShuffleMode()">
                <svg id="shuffle-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle; border-radius:8px; transition:color 0.2s, background 0.2s, box-shadow 0.2s;">
                  <polyline points="16 3 21 3 21 8" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                  <line x1="4" y1="20" x2="21" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <polyline points="21 16 21 21 16 21" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                  <line x1="15" y1="15" x2="21" y2="21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
              <select id="language-select" onchange="setLanguage(this.value, getCurrentTime())">
                <option value="4">Arabic</option>
                <option value="1" selected>English</option>
                <option value="3">Malay</option>
                <option value="5">Tagalog</option>
              </select>
              <button id="info-button" onclick="showInfo()">Info</button>
            </div>
            <ul id="episodes"></ul>

            <div class="overlay" id="overlay">
              <div class="overlay-content">
                <img id="overlay-image" alt="Episode Thumbnail" />
                <div class="overlay-content-text">
                  <h2 id="overlay-episode-number"></h2>
                  <h2 id="overlay-title"></h2>
                  <p id="overlay-description"></p>
                  <button id="download-button" onclick="downloadEpisode()">Download</button>
                </div>
              </div>
              <div class="close-overlay" onclick="closeOverlay()">X</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Toast container -->
      <div id="toast" class="toast" role="status" aria-live="polite"></div>

      <!-- ---- DARK MODE SCRIPT ---- -->
      <script>
        const themeKey = "bluey-site-theme";
        const root = document.body;
        const darkToggle = document.getElementById("darkToggle");
        function setTheme(dark) {
          if (dark) { root.classList.add('dark'); localStorage.setItem(themeKey, "dark"); }
          else { root.classList.remove('dark'); localStorage.setItem(themeKey, "light"); }
        }
        (() => {
          const saved = localStorage.getItem(themeKey);
          if (saved === "dark" || (!saved && window.matchMedia("(prefers-color-scheme: dark)").matches)) { setTheme(true); } else { setTheme(false); }
        })();
        darkToggle.onclick = () => setTheme(!root.classList.contains('dark'));
      </script>

      <!-- App Scripts (Video.js + VHS + Cast wiring) -->
      <script>
        // Toast helper
        function showToast(msg, duration = 2500) {
          const t = document.getElementById('toast');
          if (!t) return;
          t.textContent = msg;
          t.classList.add('show');
          clearTimeout(showToast._t);
          showToast._t = setTimeout(() => t.classList.remove('show'), duration);
        }

        // Map UI select -> possible language codes/tokens found in Emby streams
        const PREFERRED_LANGS = {
          '1': ['eng','en','english'],
          '3': ['msa','may','zsm','ms','malay','bahasa melayu'],
          '4': ['ara','ar','arabic','العربية'],
          '5': ['tgl','fil','tl','tagalog','filipino']
        };

        function normalizeLangHint(stream) {
          const a = [
            stream.Language,
            stream.DisplayLanguage,
            stream.DisplayTitle,
            stream.Title,
            stream.Codec
          ].filter(Boolean).join(' ').toLowerCase();
          return a;
        }

        function pickAudioStreamIndex(audioStreams, preferredKey) {
          if (!audioStreams || audioStreams.length === 0) return { index: null, reason: 'none' };

          const hints = PREFERRED_LANGS[String(preferredKey)] || [];
          const want = (s) => {
            const h = normalizeLangHint(s);
            return hints.some(code => h.includes(code));
          };

          // 1) exact preference
          const pref = audioStreams.find(want);
          if (pref) return { index: pref.Index, reason: 'pref' };

          // 2) English fallback
          const eng = audioStreams.find(s => /(^|[^a-z])(eng|english|en)([^a-z]|$)/.test(normalizeLangHint(s)));
          if (eng) return { index: eng.Index, reason: 'fallback_en' };

          // 3) whatever is first
          return { index: audioStreams[0].Index, reason: 'fallback_first' };
        }

        // Global configuration and state variables
        const serverUrl = "https://blueynet.org:443";
        const apiKey = "6b2548952ea2439ea800b8cd3f1072d1";
        const itemId = "11";
        const LANG_STORAGE_KEY = "bluey_watch_selected_language_episodes";

        // Language selection state
        let selectedAudioStreamIndex = 1; // default to English (user preference key)
        let userPreferredLanguage = selectedAudioStreamIndex;
        let currentAudioStreamIndexUsed = null; // actual Emby stream Index chosen for current episode

        // Episode and season state
        let selectedSeason = null;
        let episodes = [];
        let currentEpisodeIndex = -1;
        let episodesCache = {};

        let seasonsList = [];
        let currentSeason = null;
        let currentSeasonIndex = -1;

        // Shuffle state
        let allEpisodes = [];
        let shuffleMode = false;

        // Subtitles persistence
        let subsWanted = localStorage.getItem('bluey_subtitle_on') === '1';

        // --- Player init (unmuted by default) ---
        const VOL_KEY = 'bluey_vol';

        // >>> CAST: metadata holders the Chromecast plugin will read
        window.__castTitle = '';
        window.__castSubtitle = '';
        window.__castPoster = '';
        window.__castMP4 = '';
        window.__isCasting = false;

        const player = videojs('bluey', {
          controls: true,
          preload: 'auto',
          muted: false,
          fluid: true,
          techOrder: ['chromecast', 'html5'],
          plugins: {
            // >>> CAST: feed title/subtitle & tweak what the Cast receiver loads
            chromecast: {
              receiverAppID: 'CC1AD845',
              addButtonToControlBar: true,
              requestTitleFn: () => window.__castTitle || document.title,
              requestSubtitleFn: () => window.__castSubtitle || '',
              modifyLoadRequestFn: (request) => {
                // Prefer MP4 for maximum Cast compatibility.
                if (window.__castMP4) {
                  request.media.contentId = window.__castMP4;
                  request.media.contentType = 'video/mp4';
                }
                // Ensure poster artwork
                if (window.__castPoster) {
                  request.media.metadata = request.media.metadata || new chrome.cast.media.GenericMediaMetadata();
                  request.media.metadata.images = [{ url: window.__castPoster }];
                }
                request.autoplay = true;
                return request;
              }
            }
          },
          html5: {
            vhs: {
              smoothQualityChange: true,
              limitRenditionByPlayerDimensions: true,
              overrideNative: false
            }
          }
        });

        // Episode title overlay component (shows only when controls are visible)
        const BaseComp = videojs.getComponent('Component');
        class TitleOverlay extends BaseComp {
          createEl() {
            const el = videojs.dom.createEl('div', { className: 'vjs-episode-title' });
            el.textContent = '';
            return el;
          }
          set(text) { this.el().textContent = text || ''; }
        }
        videojs.registerComponent('TitleOverlay', TitleOverlay);
        const titleOverlay = player.addChild('TitleOverlay', {});
        function setPlayerTitle(text) { if (titleOverlay) titleOverlay.set(text); }

        // Persist caption ON/OFF
        player.on('texttrackchange', () => {
          const on = Array.from(player.textTracks()).some(t => t.mode === 'showing');
          subsWanted = on; localStorage.setItem('bluey_subtitle_on', on ? '1' : '0');
        });

        // Default volume + persist (and ensure not muted)
        player.ready(() => {
          const savedVol = parseFloat(localStorage.getItem(VOL_KEY));
          try { player.muted(false); } catch {}
          player.volume(!isNaN(savedVol) ? savedVol : 0.8);
        });
        player.on('volumechange', () => {
          localStorage.setItem(VOL_KEY, String(player.volume()));
        });

        // >>> CAST: connected / disconnected flags + robust auto-next fallback
        player.on('chromecastConnected', () => {
          window.__isCasting = true;
          attachCastMediaListener(); // fallback listener to detect FINISHED
        });
        player.on('chromecastDisconnected', () => {
          window.__isCasting = false;
          detachCastMediaListener();
        });

        let castMedia = null;
        function attachCastMediaListener() {
          try {
            const ctx = cast && cast.framework && cast.framework.CastContext.getInstance();
            const session = ctx && ctx.getCurrentSession();
            castMedia = session && session.getMediaSession();
            if (castMedia) {
              castMedia.addUpdateListener(castMediaUpdate);
            }
          } catch {}
        }
        function detachCastMediaListener() {
          try { if (castMedia) castMedia.removeUpdateListener(castMediaUpdate); } catch {}
          castMedia = null;
        }
        function castMediaUpdate(/*isAlive*/) {
          try {
            if (!castMedia) return;
            if (castMedia.playerState === chrome.cast.media.PlayerState.IDLE &&
                castMedia.idleReason === chrome.cast.media.IdleReason.FINISHED) {
              queueNextEpisode(); // fallback trigger (in case 'ended' didn't bubble)
            }
          } catch {}
        }

        // Load saved language
        document.addEventListener('DOMContentLoaded', () => {
          const saved = localStorage.getItem(LANG_STORAGE_KEY);
          if (saved !== null) {
            selectedAudioStreamIndex = parseInt(saved, 10);
            userPreferredLanguage = selectedAudioStreamIndex;
            document.getElementById('language-select').value = saved;
          }

          fetchSeasons();
          document.getElementById('episodes').innerHTML = '';

          window.addEventListener('resize', updateOrientationUI);
          document.addEventListener('DOMContentLoaded', updateOrientationUI);
        });

        // MediaSession prev/next hooks (local device)
        function wireMediaSession(episode) {
          if (!('mediaSession' in navigator)) return;
          navigator.mediaSession.metadata = new MediaMetadata({
            title: `S${episode.ParentIndexNumber}E${episode.IndexNumber}: ${episode.Name}`,
            artist: 'Bluey',
            album: `Season ${episode.ParentIndexNumber}`,
            artwork: [{ src: `${serverUrl}/emby/Items/${episode.Id}/Images/Primary?api_key=${apiKey}`, sizes: '1920x1080', type: 'image/png' }]
          });
          navigator.mediaSession.setActionHandler('previoustrack', () => jumpPrev());
          navigator.mediaSession.setActionHandler('nexttrack', () => jumpNext());
        }
        function jumpPrev() {
          if (shuffleMode && allEpisodes.length > 1) {
            let prevIndex; const currentId = episodes[currentEpisodeIndex]?.Id;
            do { prevIndex = Math.floor(Math.random() * allEpisodes.length); } while (allEpisodes[prevIndex].Id === currentId);
            const prevEp = allEpisodes[prevIndex];
            const season = seasonsList.find(s => s.Id === prevEp.SeasonId);
            if (season) {
              currentSeason = season; currentSeasonIndex = seasonsList.indexOf(season);
              episodes = episodesCache[season.Id] || []; renderEpisodes(episodes);
              const epIndex = episodes.findIndex(e => e.Id === prevEp.Id);
              if (epIndex !== -1) { currentEpisodeIndex = epIndex; playEpisode(prevEp, epIndex); }
            }
          } else if (currentEpisodeIndex > 0) {
            currentEpisodeIndex--; playEpisode(episodes[currentEpisodeIndex], currentEpisodeIndex);
          } else if (currentSeasonIndex > 0) {
            currentSeasonIndex--; currentSeason = seasonsList[currentSeasonIndex];
            episodes = episodesCache[currentSeason.Id] || []; renderEpisodes(episodes);
            currentEpisodeIndex = episodes.length - 1; playEpisode(episodes[currentEpisodeIndex], currentEpisodeIndex);
          }
        }
        function jumpNext() {
          if (shuffleMode && allEpisodes.length > 1) {
            let nextIndex; const currentId = episodes[currentEpisodeIndex]?.Id;
            do { nextIndex = Math.floor(Math.random() * allEpisodes.length); } while (allEpisodes[nextIndex].Id === currentId);
            const nextEp = allEpisodes[nextIndex];
            const season = seasonsList.find(s => s.Id === nextEp.SeasonId);
            if (season) {
              currentSeason = season; currentSeasonIndex = seasonsList.indexOf(season);
              episodes = episodesCache[season.Id] || []; renderEpisodes(episodes);
              const epIndex = episodes.findIndex(e => e.Id === nextEp.Id);
              if (epIndex !== -1) { currentEpisodeIndex = epIndex; playEpisode(nextEp, epIndex); }
            }
          } else if (currentEpisodeIndex < episodes.length - 1) {
            currentEpisodeIndex++; playEpisode(episodes[currentEpisodeIndex], currentEpisodeIndex);
          } else if (currentSeasonIndex < seasonsList.length - 1) {
            currentSeasonIndex++; currentSeason = seasonsList[currentSeasonIndex];
            episodes = episodesCache[currentSeason.Id] || []; renderEpisodes(episodes);
            currentEpisodeIndex = 0; playEpisode(episodes[0], 0);
          }
        }

        // Autoplay helper handling browser policies (unmuted)
        async function autoPlayMaybe(seek) {
          if (typeof seek === 'number') { try { player.currentTime(seek); } catch {} }
          try {
            await player.play(); // try with sound
          } catch (e) {
            try { player.muted(false); } catch {}
            player.bigPlayButton.show(); // wait for user gesture; keep unmuted
            player.one('play', () => player.muted(false));
          }
        }

        // Build URLs for Emby (with optional audio stream index)
        function buildHlsUrl(episode, mediaSourceId, PlaySessionId, VideoBitRate, AudioBitRate, audioIndex) {
          let url = `${serverUrl}/emby/videos/${episode.Id}/master.m3u8` +
                    `?MediaSourceId=${mediaSourceId}` +
                    `&PlaySessionId=${PlaySessionId}` +
                    `&api_key=${apiKey}` +
                    `&VideoCodec=h264&AudioCodec=aac` +
                    `&VideoBitrate=${VideoBitRate}&AudioBitrate=${AudioBitRate}` +
                    `&TranscodingMaxAudioChannels=2` +
                    `&SegmentContainer=fmp4&MinSegments=2&h264-profile=main`;
          if (typeof audioIndex === 'number') url += `&AudioStreamIndex=${audioIndex}`;
          return url;
        }

        function buildMp4Url(episode, audioIndex) {
          let url = `${serverUrl}/emby/videos/${episode.Id}/stream.mp4?Static=true&api_key=${apiKey}`;
          if (typeof audioIndex === 'number') url += `&AudioStreamIndex=${audioIndex}`;
          return url;
        }

        // Current time
        function getCurrentTime() { return player.currentTime() || 0; }

        // PLAY EPISODE
        let onEndedHandler = null;
        async function playEpisode(episode, index, seekTime) {
          wireMediaSession(episode);

          const niceTitle = `S${episode.ParentIndexNumber}E${episode.IndexNumber}: ${episode.Name}`;
          setPlayerTitle(niceTitle);
          document.title = `Watch Bluey! | ${niceTitle}`;

          // >>> CAST metadata defaults (poster/title); MP4 assigned after URL build
          const poster = `${serverUrl}/emby/Items/${episode.Id}/Images/Primary?api_key=${apiKey}`;
          window.__castTitle = niceTitle;
          window.__castSubtitle = `Bluey | Season ${episode.ParentIndexNumber}`;
          window.__castPoster = poster;

          // Show player area
          document.querySelector('.player-wrapper').style.display = 'block';

          // Fetch Emby playback info
          const timestamp = Date.now();
          const info = await fetch(`${serverUrl}/emby/Items/${episode.Id}/PlaybackInfo?api_key=${apiKey}&Fields=MediaSources&t=${timestamp}`).then(r => r.json());
          const ms = info.MediaSources[0];

          // Decide which audio stream to use for this episode
          const audioStreams = (ms.MediaStreams || []).filter(s => s.Type === 'Audio');
          const pick = pickAudioStreamIndex(audioStreams, userPreferredLanguage);
          currentAudioStreamIndexUsed = pick.index;
          if (pick.reason === 'fallback_en' && String(userPreferredLanguage) !== '1') {
            showToast('Selected language not available for this episode — using English.');
          } else if (pick.reason === 'fallback_first') {
            showToast('Selected language not available — using default audio.');
          }

          const mediaSourceId = ms.Id;
          const PlaySessionId = info.PlaySessionId;
          const VideoBitRate = ms.MediaStreams[0]?.BitRate || 5000000;
          const AudioBitRate = (audioStreams.find(s => s.Index === currentAudioStreamIndexUsed)?.BitRate) || 192000;

          const hls = buildHlsUrl(episode, mediaSourceId, PlaySessionId, VideoBitRate, AudioBitRate, currentAudioStreamIndexUsed);
          const progressive = buildMp4Url(episode, currentAudioStreamIndexUsed);

          // >>> CAST: ensure receiver uses same audio selection
          window.__castMP4 = progressive;

          // Remove previous tracks
          const rtt = player.remoteTextTracks();
          for (let i = rtt.length - 1; i >= 0; i--) player.removeRemoteTextTrack(rtt[i]);

          // Set poster & source (HLS for local; Cast will swap to MP4 via modifyLoadRequestFn)
          player.poster(poster);
          player.src({ src: hls, type: 'application/x-mpegURL' });

          // Add VTT (English as default subs track path)
          const vtt = `${serverUrl}/emby/Videos/${episode.Id}/${mediaSourceId}/Subtitles/2/0/Stream.vtt?api_key=${apiKey}`;
          try { player.addRemoteTextTrack({ kind: 'subtitles', src: vtt, srclang: 'en', label: 'English' }, false); } catch {}

          // Apply subtitle preference
          const tt = player.textTracks();
          for (let i = 0; i < tt.length; i++) { tt[i].mode = subsWanted ? 'showing' : 'disabled'; }

          // Ready to play (Chromecast tech fires 'loadeddata', HTML5 fires 'loadedmetadata')
          const onReadyToPlay = async () => { try { player.muted(false); } catch {}; await autoPlayMaybe(seekTime); showInfo(); };
          player.one('loadedmetadata', onReadyToPlay);
          player.one('loadeddata', onReadyToPlay);

          // Robust auto-advance (re-bind our own handler only)
          if (onEndedHandler) player.off('ended', onEndedHandler);
          onEndedHandler = () => queueNextEpisode();
          player.on('ended', onEndedHandler);

          // Highlight current episode in list
          const prevSelected = document.querySelector('#episodes li.selected');
          if (prevSelected) prevSelected.classList.remove('selected');
          const selectedEpisodeItem = document.querySelector(`#episodes li:nth-child(${index + 1})`);
          if (selectedEpisodeItem) selectedEpisodeItem.classList.add('selected');

          renderOverlay(episode);
        }

        function queueNextEpisode() {
          if (shuffleMode && allEpisodes.length > 0) {
            let nextIndex; const currentId = episodes[currentEpisodeIndex]?.Id;
            do { nextIndex = Math.floor(Math.random() * allEpisodes.length); } while (allEpisodes.length > 1 && allEpisodes[nextIndex].Id === currentId);
            const ep = allEpisodes[nextIndex];
            const season = seasonsList.find(s => s.Id === ep.SeasonId);
            if (season) {
              currentSeason = season; currentSeasonIndex = seasonsList.indexOf(season);
              document.querySelectorAll('.season-selector__button').forEach(btn => btn.classList.remove('selected'));
              const seasonBtn = document.querySelector(`.season-selector__button[data-season-id="${season.Id}"]`);
              if (seasonBtn) seasonBtn.classList.add('selected');
              episodes = episodesCache[season.Id] || []; renderEpisodes(episodes);
              const epIndex = episodes.findIndex(e => e.Id === ep.Id);
              if (epIndex !== -1) { currentEpisodeIndex = epIndex; playEpisode(ep, epIndex); }
            }
            return;
          }
          if (currentEpisodeIndex >= 0 && currentEpisodeIndex + 1 < episodes.length) {
            currentEpisodeIndex++; playEpisode(episodes[currentEpisodeIndex], currentEpisodeIndex);
          } else if (currentEpisodeIndex >= 0 && currentSeasonIndex < seasonsList.length - 1) {
            currentSeasonIndex++; currentSeason = seasonsList[currentSeasonIndex];
            document.querySelectorAll('.season-selector__button').forEach(btn => btn.classList.remove('selected'));
            const nextSeasonButton = document.querySelector(`.season-selector__button[data-season-id="${currentSeason.Id}"]`);
            if (nextSeasonButton) nextSeasonButton.classList.add('selected');
            if (episodesCache[currentSeason.Id]) { episodes = episodesCache[currentSeason.Id]; renderEpisodes(episodes); currentEpisodeIndex = 0; playEpisode(episodes[0], 0); }
            else { fetchEpisodes(currentSeason); }
          }
        }

        function prefetchEpisodes(season) {
          if (!episodesCache[season.Id]) {
            fetch(`${serverUrl}/emby/Shows/${itemId}/Episodes?SeasonId=${season.Id}&api_key=${apiKey}&Fields=Overview`)
              .then(r => r.json())
              .then(data => {
                episodesCache[season.Id] = data.Items;
                data.Items.forEach(ep => { if (!allEpisodes.find(e => e.Id === ep.Id)) { allEpisodes.push(ep); } });
              })
              .catch(err => console.error('prefetch error:', err));
          }
        }

        function fetchSeasons() {
          fetch(`${serverUrl}/emby/Shows/${itemId}/Seasons?api_key=${apiKey}`)
            .then(r => r.json())
            .then(seasons => {
              const seasonsContainer = document.getElementById('seasons');
              seasonsList = seasons.Items.filter(season => season.SeriesId === itemId);
              seasonsList.forEach((season, i) => {
                prefetchEpisodes(season);
                const seasonBtn = document.createElement('button');
                seasonBtn.classList.add('season-selector__button');
                seasonBtn.innerText = `Season ${season.IndexNumber}`;
                seasonBtn.setAttribute('data-season-id', season.Id);
                seasonBtn.addEventListener('click', () => {
                  handleSeasonClick(seasonBtn, season, i);
                  if (episodesCache[season.Id]) { episodes = episodesCache[season.Id]; renderEpisodes(episodes); }
                  else { fetchEpisodes(season); }
                });
                seasonsContainer.appendChild(seasonBtn);
              });
            })
            .catch(err => console.error('seasons error:', err));
        }

        function fetchEpisodes(season) {
          fetch(`${serverUrl}/emby/Shows/${itemId}/Episodes?SeasonId=${season.Id}&api_key=${apiKey}&Fields=Overview`)
            .then(r => r.json())
            .then(data => {
              episodesCache[season.Id] = data.Items; episodes = data.Items;
              data.Items.forEach(ep => { if (!allEpisodes.find(e => e.Id === ep.Id)) { allEpisodes.push(ep); } });
              renderEpisodes(episodes);
            })
            .catch(err => console.error('episodes error:', err));
        }

        function handleSeasonClick(button, season, seasonIndex) {
          if (selectedSeason) selectedSeason.classList.remove('selected');
          selectedSeason = button; selectedSeason.classList.add('selected');
          currentSeason = season; currentSeasonIndex = seasonIndex; currentEpisodeIndex = -1;
        }

        function renderEpisodes(episodesArr) {
          const episodeList = document.getElementById('episodes');
          episodeList.innerHTML = '';
          episodesArr.forEach((episode, index) => {
            const li = document.createElement('li');
            li.innerHTML = `
              <img src="${serverUrl}/emby/Items/${episode.Id}/Images/Primary?api_key=${apiKey}" alt="Episode Thumbnail">
              <div>
                <h2>Episode ${episode.IndexNumber}: ${episode.Name}</h2>
                <p>${episode.Overview}</p>
              </div>
            `;
            li.addEventListener('click', () => { currentEpisodeIndex = index; playEpisode(episode, index); });
            if (currentEpisodeIndex === index) li.classList.add('selected');
            episodeList.appendChild(li);
          });
        }

        function renderOverlay(episode) {
          if (window.innerHeight > window.innerWidth) {
            const overlay = document.getElementById('overlay');
            const overlayImage = document.getElementById('overlay-image');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayDescription = document.getElementById('overlay-description');
            const overlayEpisodeNumber = document.getElementById('overlay-episode-number');
            overlayImage.src = `${serverUrl}/emby/Items/${episode.Id}/Images/Primary?api_key=${apiKey}`;
            overlayEpisodeNumber.innerText = `S${episode.ParentIndexNumber}E${episode.IndexNumber}`;
            overlayTitle.innerText = episode.Name;
            overlayDescription.innerText = episode.Overview;
            overlay.style.display = 'block';
            const desc = document.getElementById('landscape-description');
            if (desc) desc.style.display = 'none';
          } else {
            const desc = document.getElementById('landscape-description');
            desc.innerHTML = `
              <img src="${serverUrl}/emby/Items/${episode.Id}/Images/Primary?api_key=${apiKey}" alt="Episode Thumbnail" style="width:120px; height:auto; float:left; margin-right:15px;">
              <div style="overflow: hidden;">
                <h2 style="margin-bottom:10px;">S${episode.ParentIndexNumber}E${episode.IndexNumber}: ${episode.Name}</h2>
                <p>${episode.Overview}</p>
                <button id="download-button-landscape" onclick="downloadEpisode()" style="cursor:pointer; color:#ffffff; background-color:#e2793b; padding:10px 20px; border:none; border-radius:5px; font-family:'Hello Headline', sans-serif; margin-top:10px;">Download</button>
              </div>
              <div style="clear: both;"></div>
            `;
            desc.style.display = 'block';
            document.getElementById('overlay').style.display = 'none';
          }
        }

        function closeOverlay() { document.getElementById('overlay').style.display = 'none'; }
        function showInfo() { if (currentEpisodeIndex >= 0 && episodes[currentEpisodeIndex]) renderOverlay(episodes[currentEpisodeIndex]); }

        function downloadEpisode() {
          if (currentEpisodeIndex >= 0 && episodes[currentEpisodeIndex]) {
            const episode = episodes[currentEpisodeIndex];
            const downloadUrl = `${serverUrl}/emby/Items/${episode.Id}/Download?api_key=${apiKey}`;
            window.location.href = downloadUrl;
          }
        }

        function setLanguage(value, seekTime) {
          selectedAudioStreamIndex = parseInt(value, 10);
          userPreferredLanguage = selectedAudioStreamIndex;
          localStorage.setItem(LANG_STORAGE_KEY, value);
          if (episodes.length > 0 && currentEpisodeIndex >= 0) {
            playEpisode(episodes[currentEpisodeIndex], currentEpisodeIndex, seekTime);
          }
        }

        function updateOrientationUI() {
          const infoButton = document.getElementById('info-button');
          const landscapeDesc = document.getElementById('landscape-description');
          if (window.innerHeight > window.innerWidth) {
            infoButton.style.display = 'block'; if (landscapeDesc) landscapeDesc.style.display = 'none';
          } else {
            infoButton.style.display = 'none';
            if (currentEpisodeIndex >= 0 && episodes[currentEpisodeIndex]) renderOverlay(episodes[currentEpisodeIndex]);
          }
        }

        document.addEventListener('fullscreenchange', () => {
          if (document.fullscreenElement) {
            if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(() => {});
          } else {
            if (screen.orientation && screen.orientation.unlock) screen.orientation.unlock();
          }
        });

        function toggleShuffleMode() {
          shuffleMode = !shuffleMode;
          const shuffleIcon = document.getElementById('shuffle-icon');
          if (shuffleMode) shuffleIcon.classList.add('active'); else shuffleIcon.classList.remove('active');
        }
      </script>
    </div>
  </body>
</html>
